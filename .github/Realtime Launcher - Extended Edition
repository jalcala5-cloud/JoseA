#!/usr/bin/env python3
"""
Realtime Launcher - Extended Edition
macOS-friendly Tkinter app implementing:
- 12-hour clock with seconds and AM/PM (updates every second)
- Calendar refreshed every second with pink square on today's date
- Scrolling marquee (remind-me) with editable text & multicolor option
- Top-right fullscreen / small-screen toggle
- Quick apps + addable web & local apps
- Settings: background color/image, auto-dark-mode, font color, label sizes
- Automation command run every second (non-blocking)
- Add calendar events (in-memory)
- Widgets area (add simple text widgets)
- Refresh and Reset buttons
"""
import tkinter as tk
from tkinter import ttk, colorchooser, filedialog, simpledialog
from tkinter import font as tkfont
from datetime import datetime, date
import calendar
import webbrowser
import subprocess
import threading
import time
import os
from PIL import Image, ImageTk
import json

# Config (in-memory). You can extend to save/load from disk if you'd like.
cfg = {
    "title": "Realtime Launcher",
    "bg_color": "#1f2226",
    "font_color": "#f1f1f1",
    "font_family": "Helvetica",
    "clock_size": 44,
    "date_size": 14,
    "marquee_text": "Reminder: Drink water • Meeting at 3pm • Take a break",
    "marquee_speed": 4,
    "marquee_multicolor": False,
    "bg_image": None,
    "added_urls": [],      # list of (name, url)
    "added_apps": [],      # list of (name, path)
    "automation_cmd": None,
    "auto_dark": True,
    "widgets": [],         # list of simple widgets (text)
    "calendar_events": {}, # keyed by "YYYY-MM-DD": [events]
    "fullscreen": False
}

UPDATE_MS = 1000

# helper to run shell commands without blocking
def run_cmd_nonblocking(cmd):
    if not cmd:
        return
    def target():
        try:
            subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print("Automation error:", e)
    t = threading.Thread(target=target, daemon=True)
    t.start()

class RealtimeLauncher(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(cfg["title"])
        self.configure(bg=cfg["bg_color"])
        self.geometry("1150x720")
        self.minsize(900, 520)

        # fonts
        self.clock_font = tkfont.Font(family=cfg["font_family"], size=cfg["clock_size"], weight="bold")
        self.date_font = tkfont.Font(family=cfg["font_family"], size=cfg["date_size"])
        self.marquee_font = tkfont.Font(family=cfg["font_family"], size=18)
        self.label_font = tkfont.Font(family=cfg["font_family"], size=12)

        self.bg_photo = None

        # Top bar (title, url/search, AI chat input, fullscreen switch)
        self.topbar = tk.Frame(self, bg=cfg["bg_color"])
        self.topbar.pack(side="top", fill="x", padx=10, pady=8)

        self.title_lbl = tk.Label(self.topbar, text=cfg["title"], bg=cfg["bg_color"], fg=cfg["font_color"],
                                  font=tkfont.Font(family=cfg["font_family"], size=18, weight="bold"))
        self.title_lbl.pack(side="left", padx=(4,12))

        self.url_var = tk.StringVar()
        self.url_entry = ttk.Entry(self.topbar, textvariable=self.url_var, width=50)
        self.url_entry.pack(side="left", padx=6)
        self.url_entry.bind("<Return>", self.open_url)

        self.open_url_btn = ttk.Button(self.topbar, text="Open URL", command=self.open_url)
        self.open_url_btn.pack(side="left", padx=6)

        # AI chat/ask input (simple open search to ChatGPT or run a local command if desired)
        self.ai_var = tk.StringVar()
        self.ai_entry = ttk.Entry(self.topbar, textvariable=self.ai_var, width=28)
        self.ai_entry.pack(side="left", padx=(12,4))
        self.ai_entry.bind("<Return>", self.ask_ai)
        self.ai_btn = ttk.Button(self.topbar, text="Ask/Chat AI", command=self.ask_ai)
        self.ai_btn.pack(side="left", padx=4)

        # fullscreen switch on top-right
        self.full_btn = ttk.Button(self.topbar, text="⤢ Fullscreen", command=self.toggle_fullscreen)
        self.full_btn.pack(side="right", padx=8)

        # refresh and reset buttons
        self.refresh_btn = ttk.Button(self.topbar, text="Refresh", command=self.refresh_ui)
        self.refresh_btn.pack(side="right", padx=6)
        self.reset_btn = ttk.Button(self.topbar, text="Reset", command=self.reset_defaults)
        self.reset_btn.pack(side="right", padx=6)

        # main content
        self.content = tk.Frame(self, bg=cfg["bg_color"])
        self.content.pack(fill="both", expand=True, padx=12, pady=6)

        # LEFT: clock, marquee, quick apps, widgets
        self.left_pane = tk.Frame(self.content, bg=cfg["bg_color"])
        self.left_pane.pack(side="left", fill="both", expand=True)

        # Clock + date
        self.clock_frame = tk.Frame(self.left_pane, bg=cfg["bg_color"])
        self.clock_frame.pack(side="top", anchor="nw", fill="x", pady=(6,8))

        self.time_var = tk.StringVar()
        self.time_lbl = tk.Label(self.clock_frame, textvariable=self.time_var, font=self.clock_font,
                                 bg=cfg["bg_color"], fg=cfg["font_color"])
        self.time_lbl.pack(anchor="w")

        self.date_var = tk.StringVar()
        self.date_lbl = tk.Label(self.clock_frame, textvariable=self.date_var, font=self.date_font,
                                 bg=cfg["bg_color"], fg=cfg["font_color"])
        self.date_lbl.pack(anchor="w")

        # marquee canvas
        self.marquee_canvas = tk.Canvas(self.left_pane, height=40, bg=cfg["bg_color"], highlightthickness=0)
        self.marquee_canvas.pack(fill="x", pady=(8,10))
        self.marquee_text_id = None
        self.marquee_x = 0

        # quick app buttons
        self.quick_frame = tk.Frame(self.left_pane, bg=cfg["bg_color"])
        self.quick_frame.pack(fill="x", pady=(6,10))
        self.add_quick_buttons()

        # user-added apps
        self.user_apps_frame = tk.Frame(self.left_pane, bg=cfg["bg_color"])
        self.user_apps_frame.pack(fill="x", pady=(6,10))

        # widgets area
        self.widget_frame = tk.Frame(self.left_pane, bg=cfg["bg_color"])
        self.widget_frame.pack(fill="both", expand=True, pady=(6,12))
        self.widget_label = tk.Label(self.widget_frame, text="Widgets", bg=cfg["bg_color"], fg=cfg["font_color"])
        self.widget_label.pack(anchor="nw", padx=6)
        self.widgets_inner = tk.Frame(self.widget_frame, bg=cfg["bg_color"])
        self.widgets_inner.pack(fill="both", expand=True, padx=6, pady=6)

        # RIGHT: calendar and features box
        self.right_pane = tk.Frame(self.content, width=360, bg=cfg["bg_color"])
        self.right_pane.pack(side="right", fill="y", padx=(8,0))

        self.calendar_canvas = tk.Canvas(self.right_pane, width=340, bg=cfg["bg_color"], highlightthickness=0)
        self.calendar_canvas.pack(padx=8, pady=8)

        self.features_box = tk.Frame(self.right_pane, bg=cfg["bg_color"], bd=1, relief="ridge")
        self.features_box.pack(fill="x", padx=8, pady=(6,12))
        self.features_label = tk.Label(self.features_box, text="Features", bg=cfg["bg_color"], fg=cfg["font_color"])
        self.features_label.pack(anchor="nw", padx=8, pady=6)

        # feature controls
        controls_frame = tk.Frame(self.features_box, bg=cfg["bg_color"])
        controls_frame.pack(fill="x", padx=8, pady=6)
        ttk.Button(controls_frame, text="Settings", command=self.open_settings).pack(side="left", padx=4)
        ttk.Button(controls_frame, text="Add Event", command=self.add_calendar_event).pack(side="left", padx=4)
        ttk.Button(controls_frame, text="Run Automation Now", command=self.run_automation_now).pack(side="left", padx=4)

        # status bar
        self.status_var = tk.StringVar(value="Ready")
        self.status_bar = tk.Label(self, textvariable=self.status_var, anchor="w", bg="#111", fg="#ddd")
        self.status_bar.pack(side="bottom", fill="x")

        # initialize UI
        self.marquee_item = None
        self.after(0, self.periodic_update)  # start update loop

    # --- UI helpers ---
    def add_quick_buttons(self):
        # Clear existing quick_frame children
        for c in self.quick_frame.winfo_children():
            c.destroy()
        built = [
            ("Docs", "https://docs.google.com/"),
            ("Gmail", "https://mail.google.com/"),
            ("ChatGPT", "https://chat.openai.com/"),
            ("YouTube", "https://www.youtube.com/"),
            ("Spotify", "https://open.spotify.com/"),
            ("D2L", "https://d2l.mydomain.edu/")  # placeholder
        ]
        for name, url in built:
            b = ttk.Button(self.quick_frame, text=name, command=lambda u=url: webbrowser.open(u))
            b.pack(side="left", padx=6)
        # Terminal and Documents quick apps
        ttk.Button(self.quick_frame, text="Terminal", command=self.open_terminal).pack(side="left", padx=6)
        ttk.Button(self.quick_frame, text="Documents", command=self.open_documents).pack(side="left", padx=6)

    def open_url(self, event=None):
        raw = self.url_var.get().strip()
        if not raw:
            return
        if raw.startswith("http://") or raw.startswith("https://"):
            webbrowser.open(raw)
        else:
            # treat as search
            query = raw.replace(" ", "+")
            webbrowser.open(f"https://www.google.com/search?q={query}")

    def ask_ai(self, event=None):
        q = self.ai_var.get().strip()
        if not q:
            return
        # simple default: open ChatGPT with the query as search (ChatGPT doesn't accept GET queries normally).
        # We open Google search and let user pick ChatGPT or open chat.openai.com
        webbrowser.open(f"https://www.google.com/search?q={q}+chatgpt")
        self.status_var.set("Opened web search for AI query")

    def open_terminal(self):
        try:
            if os.name == "posix":
                subprocess.Popen(["open", "-a", "Terminal"])
            else:
                subprocess.Popen(["cmd.exe"])
            self.status_var.set("Opened Terminal")
        except Exception as e:
            self.status_var.set("Could not open Terminal: " + str(e))

    def open_documents(self):
        try:
            docs_path = os.path.expanduser("~/Documents")
            if os.name == "posix":
                subprocess.Popen(["open", docs_path])
            else:
                subprocess.Popen(["explorer", docs_path])
            self.status_var.set("Opened Documents folder")
        except Exception as e:
            self.status_var.set("Could not open Documents: " + str(e))

    # --- settings dialog ---
    def open_settings(self):
        dlg = tk.Toplevel(self)
        dlg.title("Settings")
        dlg.transient(self)
        dlg.grab_set()
        dlg.geometry("620x520")

        # appearance
        ttk.Label(dlg, text="Appearance", font=("Helvetica", 12, "bold")).pack(anchor="w", padx=12, pady=(8,4))
        def pick_bg_color():
            c = colorchooser.askcolor(initialcolor=cfg["bg_color"])
            if c and c[1]:
                cfg["bg_color"] = c[1]
                self.apply_theme()
        ttk.Button(dlg, text="Pick Background Color", command=pick_bg_color).pack(anchor="w", padx=12, pady=4)
        def pick_font_color():
            c = colorchooser.askcolor(initialcolor=cfg["font_color"])
            if c and c[1]:
                cfg["font_color"] = c[1]
                self.apply_theme()
        ttk.Button(dlg, text="Pick Font Color", command=pick_font_color).pack(anchor="w", padx=12, pady=4)

        def pick_bg_image():
            path = filedialog.askopenfilename(filetypes=[("Images","*.png *.jpg *.jpeg *.gif *.bmp")])
            if path:
                cfg["bg_image"] = path
                self.load_bg_image(path)
                self.apply_theme()
        ttk.Button(dlg, text="Upload Background Image", command=pick_bg_image).pack(anchor="w", padx=12, pady=6)

        # marquee text
        ttk.Label(dlg, text="Marquee Text:", font=("Helvetica", 11)).pack(anchor="w", padx=12, pady=(10,2))
        mentry = ttk.Entry(dlg, width=70)
        mentry.insert(0, cfg["marquee_text"])
        mentry.pack(anchor="w", padx=12, pady=4)
        def set_marquee():
            cfg["marquee_text"] = mentry.get()
            self.reset_marquee()
        ttk.Button(dlg, text="Apply Marquee Text", command=set_marquee).pack(anchor="w", padx=12, pady=4)
        mc_var = tk.BooleanVar(value=cfg["marquee_multicolor"])
        ttk.Checkbutton(dlg, text="Multicolor Illumination (marquee)", variable=mc_var,
                        command=lambda: self.toggle_multicolor(mc_var.get())).pack(anchor="w", padx=12, pady=4)

        ttk.Separator(dlg, orient="horizontal").pack(fill="x", pady=8)

        # automation command
        ttk.Label(dlg, text="Automation Command (runs every second):", font=("Helvetica", 11)).pack(anchor="w", padx=12, pady=(6,2))
        auto_entry = ttk.Entry(dlg, width=70)
        if cfg.get("automation_cmd"):
            auto_entry.insert(0, cfg["automation_cmd"])
        auto_entry.pack(anchor="w", padx=12, pady=4)
        def set_auto():
            cmd = auto_entry.get().strip()
            cfg["automation_cmd"] = cmd if cmd else None
            self.status_var.set("Automation command updated")
        ttk.Button(dlg, text="Set Automation Command", command=set_auto).pack(anchor="w", padx=12, pady=4)

        # add web shortcut
        ttk.Label(dlg, text="Add Web Shortcut (name + URL):", font=("Helvetica", 11)).pack(anchor="w", padx=12, pady=(10,2))
        name_e = ttk.Entry(dlg, width=24); name_e.pack(anchor="w", padx=12, pady=(0,4))
        url_e = ttk.Entry(dlg, width=56); url_e.pack(anchor="w", padx=12, pady=(0,6))
        def add_url():
            n = name_e.get().strip(); u = url_e.get().strip()
            if n and u:
                cfg["added_urls"].append((n,u)); self.add_url_button(n,u)
                name_e.delete(0,"end"); url_e.delete(0,"end")
                self.status_var.set(f"Added URL: {n}")
        ttk.Button(dlg, text="Add Web Shortcut", command=add_url).pack(anchor="w", padx=12, pady=4)

        # add local app
        ttk.Label(dlg, text="Add Local App/Executable:", font=("Helvetica", 11)).pack(anchor="w", padx=12, pady=(10,2))
        def add_local_app():
            path = filedialog.askopenfilename(title="Choose application or executable")
            if path:
                name = os.path.basename(path)
                cfg["added_apps"].append((name, path))
                self.add_local_app_button(name, path)
                self.status_var.set("Added local app: " + name)
        ttk.Button(dlg, text="Choose Local App", command=add_local_app).pack(anchor="w", padx=12, pady=4)

        # add widget
        ttk.Label(dlg, text="Add Widget (text):", font=("Helvetica", 11)).pack(anchor="w", padx=12, pady=(10,2))
        wtext = ttk.Entry(dlg, width=60)
        wtext.pack(anchor="w", padx=12, pady=4)
        def add_widget():
            t = wtext.get().strip()
            if t:
                cfg["widgets"].append(t)
                self.render_widgets()
                wtext.delete(0,"end")
        ttk.Button(dlg, text="Add Widget", command=add_widget).pack(anchor="w", padx=12, pady=4)

        # Auto-dark mode
        ad_var = tk.BooleanVar(value=cfg["auto_dark"])
        ttk.Checkbutton(dlg, text="Auto Dark Mode", variable=ad_var, command=lambda: self.toggle_auto_dark(ad_var.get())).pack(anchor="w", padx=12, pady=6)

        # screen size shortcut
        size_frame = ttk.Frame(dlg); size_frame.pack(anchor="w", padx=12, pady=8)
        ttk.Button(size_frame, text="Small Screen", command=lambda: self.geometry("900x520")).pack(side="left", padx=6)
        ttk.Button(size_frame, text="Default Size", command=lambda: self.geometry("1150x720")).pack(side="left", padx=6)
        ttk.Button(size_frame, text="Fullscreen", command=lambda: self.attributes("-fullscreen", True)).pack(side="left", padx=6)

        # close
        ttk.Button(dlg, text="Close", command=dlg.destroy).pack(side="bottom", pady=10)

    def toggle_auto_dark(self, val):
        cfg["auto_dark"] = bool(val)
        # simple behavior: if auto dark is false, set background to light and font dark (as an example)
        if cfg["auto_dark"]:
            cfg["bg_color"] = "#1f2226"; cfg["font_color"] = "#f1f1f1"
        else:
            cfg["bg_color"] = "#f5f5f5"; cfg["font_color"] = "#222222"
        self.apply_theme()

    def toggle_multicolor(self, val):
        cfg["marquee_multicolor"] = bool(val)
        self.reset_marquee()

    def add_url_button(self, name, url):
        b = ttk.Button(self.user_apps_frame, text=name, command=lambda u=url: webbrowser.open(u))
        b.pack(side="left", padx=4, pady=4)

    def add_local_app_button(self, name, path):
        def opener():
            try:
                if os.name == "posix":
                    subprocess.Popen(["open", path])
                else:
                    subprocess.Popen([path], shell=True)
                self.status_var.set("Opened " + name)
            except Exception as e:
                self.status_var.set("Failed to open: " + str(e))
        b = ttk.Button(self.user_apps_frame, text=name, command=opener)
        b.pack(side="left", padx=4, pady=4)

    def load_bg_image(self, path):
        try:
            im = Image.open(path)
            w = max(300, self.winfo_width() - 200)
            h = int(im.height * (w / im.width))
            imr = im.resize((w, min(h, 400)), Image.LANCZOS)
            self.bg_photo = ImageTk.PhotoImage(imr)
            # show image in a bottom label
            if not hasattr(self, "bg_label"):
                self.bg_label = tk.Label(self.left_pane, bg=cfg["bg_color"])
                self.bg_label.pack(side="bottom", pady=6)
            self.bg_label.config(image=self.bg_photo)
        except Exception as e:
            print("BG load error:", e)
            self.status_var.set("Failed to load background image")

    def reset_marquee(self):
        self.marquee_canvas.delete("all")
        self.marquee_text_id = None
        self.marquee_x = 0

    def render_widgets(self):
        for c in self.widgets_inner.winfo_children():
            c.destroy()
        for w in cfg["widgets"]:
            lbl = tk.Label(self.widgets_inner, text=w, bg=cfg["bg_color"], fg=cfg["font_color"], font=self.label_font, bd=1, relief="groove", padx=6, pady=4)
            lbl.pack(anchor="nw", pady=4, fill="x")

    def add_calendar_event(self):
        # prompt for date and event
        dt = simpledialog.askstring("Event Date", "Enter date (YYYY-MM-DD):", parent=self)
        if not dt:
            return
        ev = simpledialog.askstring("Event Text", "Enter event description:", parent=self)
        if not ev:
            return
        lst = cfg["calendar_events"].setdefault(dt, [])
        lst.append(ev)
        self.status_var.set(f"Added event on {dt}")

    def run_automation_now(self):
        cmd = cfg.get("automation_cmd")
        if cmd:
            run_cmd_nonblocking(cmd)
            self.status_var.set("Automation executed")
        else:
            self.status_var.set("No automation command set")

    def refresh_ui(self):
        self.apply_theme()
        self.reset_marquee()
        self.render_widgets()
        self.status_var.set("UI refreshed")

    def reset_defaults(self):
        # light reset: restore some defaults. Not erasing added apps/events to avoid frustration.
        cfg.update({
            "bg_color": "#1f2226",
            "font_color": "#f1f1f1",
            "marquee_multicolor": False,
            "marquee_text": "Reminder: Drink water • Meeting at 3pm • Take a break",
            "bg_image": None,
            "automation_cmd": None,
            "fullscreen": False
        })
        self.apply_theme()
        self.reset_marquee()
        self.status_var.set("Reset to defaults")

    def toggle_fullscreen(self):
        cfg["fullscreen"] = not cfg.get("fullscreen", False)
        self.attributes("-fullscreen", cfg["fullscreen"])
        self.full_btn.config(text="Exit Fullscreen" if cfg["fullscreen"] else "⤢ Fullscreen")
        self.status_var.set("Fullscreen: " + str(cfg["fullscreen"]))

    # --- drawing / update loop ---
    def draw_calendar(self):
        self.calendar_canvas.delete("all")
        now = datetime.now()
        year, month = now.year, now.month
        monthcal = calendar.monthcalendar(year, month)
        cell_w, cell_h = 38, 28
        pad_x, pad_y = 8, 8
        # title
        title = f"{calendar.month_name[month]} {year}"
        self.calendar_canvas.create_text(170, pad_y+8, text=title, fill=cfg["font_color"], font=(cfg["font_family"], 14, "bold"))
        # weekdays
        y0 = pad_y + 30
        days = ["Su","Mo","Tu","We","Th","Fr","Sa"]
        for i, d in enumerate(days):
            self.calendar_canvas.create_text(pad_x + i*cell_w + cell_w/2, y0, text=d, fill=cfg["font_color"], font=(cfg["font_family"], 9, "bold"))
        y0 += 16
        today = date.today()
        for r, week in enumerate(monthcal):
            for c, daynum in enumerate(week):
                x = pad_x + c*cell_w
                y = y0 + r*cell_h
                # cell background
                self.calendar_canvas.create_rectangle(x, y, x+cell_w, y+cell_h, outline="#333", fill=cfg["bg_color"])
                if daynum:
                    # add small pink square on today's date
                    if daynum == today.day and month == today.month and year == today.year:
                        self.calendar_canvas.create_rectangle(x+3, y+3, x+13, y+13, fill="#ff6fb5", outline="#ff6fb5")
                    self.calendar_canvas.create_text(x + cell_w/2, y + cell_h/2, text=str(daynum), fill=cfg["font_color"], font=(cfg["font_family"], 10))

        # show events for today (if any)
        key = today.strftime("%Y-%m-%d")
        events = cfg["calendar_events"].get(key, [])
        if events:
            ev_y = y0 + len(monthcal)*cell_h + 8
            self.calendar_canvas.create_text(pad_x, ev_y, text="Events today:", anchor="w", fill=cfg["font_color"], font=(cfg["font_family"], 10, "bold"))
            for i, e in enumerate(events):
                self.calendar_canvas.create_text(pad_x, ev_y + 14*(i+1), text=f"• {e}", anchor="w", fill=cfg["font_color"], font=(cfg["font_family"], 9))

    def draw_marquee(self):
        self.marquee_canvas.delete("all")
        t = cfg["marquee_text"]
        if not t:
            return
        text_color = cfg["font_color"]
        fid = self.marquee_canvas.create_text(0, 20, text=t, anchor="w", font=self.marquee_font, fill=text_color)
        bbox = self.marquee_canvas.bbox(fid)
        if not bbox:
            return
        text_w = bbox[2]-bbox[0]
        canvas_w = max(200, self.marquee_canvas.winfo_width())
        self.marquee_x = canvas_w
        self.marquee_text_id = fid

    def update_marquee_step(self):
        if not self.marquee_text_id:
            self.draw_marquee()
            return
        try:
            self.marquee_x -= cfg["marquee_speed"]
            self.marquee_canvas.coords(self.marquee_text_id, self.marquee_x, 20)
            bbox = self.marquee_canvas.bbox(self.marquee_text_id)
            if bbox and bbox[2] < 0:
                # reset to right
                self.marquee_x = max(self.marquee_canvas.winfo_width(), 400)
                self.marquee_canvas.coords(self.marquee_text_id, self.marquee_x, 20)
            # if multicolor set, change fill color periodically
            if cfg["marquee_multicolor"]:
                # cycle by position
                colors = ["#ff6fb5","#6fb3ff","#ffd76f","#7effb2","#f87eff"]
                idx = (int(time.time()*2) % len(colors))
                self.marquee_canvas.itemconfigure(self.marquee_text_id, fill=colors[idx])
        except Exception:
            self.reset_marquee()

    def apply_theme(self):
        bg, fg = cfg["bg_color"], cfg["font_color"]
        self.configure(bg=bg)
        self.topbar.configure(bg=bg); self.title_lbl.configure(bg=bg, fg=fg)
        self.clock_frame.configure(bg=bg); self.time_lbl.configure(bg=bg, fg=fg)
        self.date_lbl.configure(bg=bg, fg=fg)
        self.left_pane.configure(bg=bg); self.right_pane.configure(bg=bg)
        self.marquee_canvas.configure(bg=bg)
        self.widget_frame.configure(bg=bg); self.widgets_inner.configure(bg=bg)
        self.features_box.configure(bg=bg); self.features_label.configure(bg=bg, fg=fg)
        self.status_bar.configure(bg="#111", fg=fg)
        # update children color where appropriate
        for lbl in self.widgets_inner.winfo_children():
            try: lbl.configure(bg=bg, fg=fg)
            except: pass

    def periodic_update(self):
        # time
        now = datetime.now()
        self.time_var.set(now.strftime("%I:%M:%S %p"))  # 12-hour with seconds and AM/PM
        self.date_var.set(now.strftime("%A, %B %d, %Y"))
        # calendar redraw
        self.draw_calendar()
        # marquee step
        self.update_marquee_step()
        # automation command executes in background thread (every second if configured)
        if cfg.get("automation_cmd"):
            run_cmd_nonblocking(cfg["automation_cmd"])
        # ensure any added buttons appear
        # render user added apps
        for c in self.user_apps_frame.winfo_children():
            c.destroy()
        for name, url in cfg["added_urls"]:
            self.add_url_button(name, url)
        for name, path in cfg["added_apps"]:
            self.add_local_app_button(name, path)
        # render widgets
        self.render_widgets()
        # schedule next tick
        self.after(UPDATE_MS, self.periodic_update)

if __name__ == "__main__":
    app = RealtimeLauncher()
    app.apply_theme()
    # load any background image if preconfigured
    if cfg.get("bg_image"):
        app.load_bg_image(cfg["bg_image"])
    app.mainloop()